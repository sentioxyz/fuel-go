// Auto generated by tools, do not edit

package fuel

import (
	"encoding/json"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

// ====================
// scalar types
// --------------------

type Address struct{ common.Hash }
type AssetId struct{ common.Hash }
type BlockId struct{ common.Hash }
type Boolean bool
type Bytes32 struct{ common.Hash }
type ContractId struct{ common.Hash }
type Float float64
type HexString struct{ hexutil.Bytes }
type ID string
type Int int32
type Nonce string
type Salt string
type Signature struct{ hexutil.Bytes }
type String string
type Tai64Timestamp uint64
type TransactionId struct{ common.Hash }
type TxPointer string
type U32 uint32
type U64 uint64
type U8 uint8
type UtxoId struct{ common.Hash }

// ====================
// enum types
// --------------------

type MessageState string

var MessageStateValues = []string{
	"UNSPENT",
	"SPENT",
	"NOT_FOUND",
}

func (e *MessageState) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range MessageStateValues {
		if v == val {
			*e = MessageState(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %q for enum type MessageState", val)
}

type ReceiptType string

var ReceiptTypeValues = []string{
	"CALL",
	"RETURN",
	"RETURN_DATA",
	"PANIC",
	"REVERT",
	"LOG",
	"LOG_DATA",
	"TRANSFER",
	"TRANSFER_OUT",
	"SCRIPT_RESULT",
	"MESSAGE_OUT",
	"MINT",
	"BURN",
}

func (e *ReceiptType) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range ReceiptTypeValues {
		if v == val {
			*e = ReceiptType(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %q for enum type ReceiptType", val)
}

type ReturnType string

var ReturnTypeValues = []string{
	"RETURN",
	"RETURN_DATA",
	"REVERT",
}

func (e *ReturnType) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range ReturnTypeValues {
		if v == val {
			*e = ReturnType(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %q for enum type ReturnType", val)
}

type RunState string

var RunStateValues = []string{
	"COMPLETED",
	"BREAKPOINT",
}

func (e *RunState) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range RunStateValues {
		if v == val {
			*e = RunState(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %q for enum type RunState", val)
}

// ====================
// object types
// --------------------

type Balance struct {
	// SCHEMA: owner Address!
	Owner Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
}

type BalanceConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [BalanceEdge!]!
	Edges []BalanceEdge
	// A list of nodes.
	// SCHEMA: nodes [Balance!]!
	Nodes []Balance
}

// An edge in a connection.
type BalanceEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node Balance!
	Node Balance
}

type Block struct {
	// SCHEMA: id BlockId!
	Id BlockId
	// SCHEMA: header Header!
	Header Header
	// SCHEMA: consensus Consensus!
	Consensus Consensus
	// SCHEMA: transactions [Transaction!]!
	Transactions []Transaction
}

type BlockConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [BlockEdge!]!
	Edges []BlockEdge
	// A list of nodes.
	// SCHEMA: nodes [Block!]!
	Nodes []Block
}

// An edge in a connection.
type BlockEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node Block!
	Node Block
}

type ChainInfo struct {
	// SCHEMA: name String!
	Name String
	// SCHEMA: latestBlock Block!
	LatestBlock Block
	// SCHEMA: daHeight U64!
	DaHeight U64
	// SCHEMA: consensusParameters ConsensusParameters!
	ConsensusParameters ConsensusParameters
	// SCHEMA: gasCosts GasCosts!
	GasCosts GasCosts
}

type ChangeOutput struct {
	// SCHEMA: to Address!
	To Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
}

type Coin struct {
	// SCHEMA: utxoId UtxoId!
	UtxoId UtxoId
	// SCHEMA: owner Address!
	Owner Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
	// SCHEMA: maturity U32!
	Maturity U32
	// TxPointer - the height of the block this coin was created in
	// SCHEMA: blockCreated U32!
	BlockCreated U32
	// TxPointer - the index of the transaction that created this coin
	// SCHEMA: txCreatedIdx U64!
	TxCreatedIdx U64
}

type CoinConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [CoinEdge!]!
	Edges []CoinEdge
	// A list of nodes.
	// SCHEMA: nodes [Coin!]!
	Nodes []Coin
}

// An edge in a connection.
type CoinEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node Coin!
	Node Coin
}

type CoinOutput struct {
	// SCHEMA: to Address!
	To Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
}

type ConsensusParameters struct {
	// SCHEMA: txParams TxParameters!
	TxParams TxParameters
	// SCHEMA: predicateParams PredicateParameters!
	PredicateParams PredicateParameters
	// SCHEMA: scriptParams ScriptParameters!
	ScriptParams ScriptParameters
	// SCHEMA: contractParams ContractParameters!
	ContractParams ContractParameters
	// SCHEMA: feeParams FeeParameters!
	FeeParams FeeParameters
	// SCHEMA: baseAssetId AssetId!
	BaseAssetId AssetId
	// SCHEMA: chainId U64!
	ChainId U64
	// SCHEMA: gasCosts GasCosts!
	GasCosts GasCosts
}

type Contract struct {
	// SCHEMA: id ContractId!
	Id ContractId
	// SCHEMA: bytecode HexString!
	Bytecode HexString
	// SCHEMA: salt Salt!
	Salt Salt
}

type ContractBalance struct {
	// SCHEMA: contract ContractId!
	Contract ContractId
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
}

type ContractBalanceConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [ContractBalanceEdge!]!
	Edges []ContractBalanceEdge
	// A list of nodes.
	// SCHEMA: nodes [ContractBalance!]!
	Nodes []ContractBalance
}

// An edge in a connection.
type ContractBalanceEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node ContractBalance!
	Node ContractBalance
}

type ContractCreated struct {
	// SCHEMA: contract Contract!
	Contract Contract
	// SCHEMA: stateRoot Bytes32!
	StateRoot Bytes32
}

type ContractOutput struct {
	// SCHEMA: inputIndex Int!
	InputIndex Int
	// SCHEMA: balanceRoot Bytes32!
	BalanceRoot Bytes32
	// SCHEMA: stateRoot Bytes32!
	StateRoot Bytes32
}

type ContractParameters struct {
	// SCHEMA: contractMaxSize U64!
	ContractMaxSize U64
	// SCHEMA: maxStorageSlots U64!
	MaxStorageSlots U64
}

type FailureStatus struct {
	// SCHEMA: transactionId TransactionId!
	TransactionId TransactionId
	// SCHEMA: block Block!
	Block Block
	// SCHEMA: time Tai64Timestamp!
	Time Tai64Timestamp
	// SCHEMA: reason String!
	Reason String
	// SCHEMA: programState ProgramState
	ProgramState *ProgramState
	// SCHEMA: receipts [Receipt!]!
	Receipts []Receipt
}

type FeeParameters struct {
	// SCHEMA: gasPriceFactor U64!
	GasPriceFactor U64
	// SCHEMA: gasPerByte U64!
	GasPerByte U64
}

type GasCosts struct {
	// SCHEMA: add U64!
	Add U64
	// SCHEMA: addi U64!
	Addi U64
	// SCHEMA: aloc U64!
	Aloc U64
	// SCHEMA: and U64!
	And U64
	// SCHEMA: andi U64!
	Andi U64
	// SCHEMA: bal U64!
	Bal U64
	// SCHEMA: bhei U64!
	Bhei U64
	// SCHEMA: bhsh U64!
	Bhsh U64
	// SCHEMA: burn U64!
	Burn U64
	// SCHEMA: cb U64!
	Cb U64
	// SCHEMA: cfei U64!
	Cfei U64
	// SCHEMA: cfsi U64!
	Cfsi U64
	// SCHEMA: croo U64!
	Croo U64
	// SCHEMA: div U64!
	Div U64
	// SCHEMA: divi U64!
	Divi U64
	// SCHEMA: ecr1 U64!
	Ecr1 U64
	// SCHEMA: eck1 U64!
	Eck1 U64
	// SCHEMA: ed19 U64!
	Ed19 U64
	// SCHEMA: eq U64!
	Eq U64
	// SCHEMA: exp U64!
	Exp U64
	// SCHEMA: expi U64!
	Expi U64
	// SCHEMA: flag U64!
	Flag U64
	// SCHEMA: gm U64!
	Gm U64
	// SCHEMA: gt U64!
	Gt U64
	// SCHEMA: gtf U64!
	Gtf U64
	// SCHEMA: ji U64!
	Ji U64
	// SCHEMA: jmp U64!
	Jmp U64
	// SCHEMA: jne U64!
	Jne U64
	// SCHEMA: jnei U64!
	Jnei U64
	// SCHEMA: jnzi U64!
	Jnzi U64
	// SCHEMA: jmpf U64!
	Jmpf U64
	// SCHEMA: jmpb U64!
	Jmpb U64
	// SCHEMA: jnzf U64!
	Jnzf U64
	// SCHEMA: jnzb U64!
	Jnzb U64
	// SCHEMA: jnef U64!
	Jnef U64
	// SCHEMA: jneb U64!
	Jneb U64
	// SCHEMA: lb U64!
	Lb U64
	// SCHEMA: log U64!
	Log U64
	// SCHEMA: lt U64!
	Lt U64
	// SCHEMA: lw U64!
	Lw U64
	// SCHEMA: mint U64!
	Mint U64
	// SCHEMA: mlog U64!
	Mlog U64
	// SCHEMA: modOp U64!
	ModOp U64
	// SCHEMA: modi U64!
	Modi U64
	// SCHEMA: moveOp U64!
	MoveOp U64
	// SCHEMA: movi U64!
	Movi U64
	// SCHEMA: mroo U64!
	Mroo U64
	// SCHEMA: mul U64!
	Mul U64
	// SCHEMA: muli U64!
	Muli U64
	// SCHEMA: mldv U64!
	Mldv U64
	// SCHEMA: noop U64!
	Noop U64
	// SCHEMA: not U64!
	Not U64
	// SCHEMA: or U64!
	Or U64
	// SCHEMA: ori U64!
	Ori U64
	// SCHEMA: poph U64!
	Poph U64
	// SCHEMA: popl U64!
	Popl U64
	// SCHEMA: pshh U64!
	Pshh U64
	// SCHEMA: pshl U64!
	Pshl U64
	// SCHEMA: ret U64!
	Ret U64
	// SCHEMA: rvrt U64!
	Rvrt U64
	// SCHEMA: sb U64!
	Sb U64
	// SCHEMA: sll U64!
	Sll U64
	// SCHEMA: slli U64!
	Slli U64
	// SCHEMA: srl U64!
	Srl U64
	// SCHEMA: srli U64!
	Srli U64
	// SCHEMA: srw U64!
	Srw U64
	// SCHEMA: sub U64!
	Sub U64
	// SCHEMA: subi U64!
	Subi U64
	// SCHEMA: sw U64!
	Sw U64
	// SCHEMA: sww U64!
	Sww U64
	// SCHEMA: time U64!
	Time U64
	// SCHEMA: tr U64!
	Tr U64
	// SCHEMA: tro U64!
	Tro U64
	// SCHEMA: wdcm U64!
	Wdcm U64
	// SCHEMA: wqcm U64!
	Wqcm U64
	// SCHEMA: wdop U64!
	Wdop U64
	// SCHEMA: wqop U64!
	Wqop U64
	// SCHEMA: wdml U64!
	Wdml U64
	// SCHEMA: wqml U64!
	Wqml U64
	// SCHEMA: wddv U64!
	Wddv U64
	// SCHEMA: wqdv U64!
	Wqdv U64
	// SCHEMA: wdmd U64!
	Wdmd U64
	// SCHEMA: wqmd U64!
	Wqmd U64
	// SCHEMA: wdam U64!
	Wdam U64
	// SCHEMA: wqam U64!
	Wqam U64
	// SCHEMA: wdmm U64!
	Wdmm U64
	// SCHEMA: wqmm U64!
	Wqmm U64
	// SCHEMA: xor U64!
	Xor U64
	// SCHEMA: xori U64!
	Xori U64
	// SCHEMA: call DependentCost!
	Call DependentCost
	// SCHEMA: ccp DependentCost!
	Ccp DependentCost
	// SCHEMA: csiz DependentCost!
	Csiz DependentCost
	// SCHEMA: k256 DependentCost!
	K256 DependentCost
	// SCHEMA: ldc DependentCost!
	Ldc DependentCost
	// SCHEMA: logd DependentCost!
	Logd DependentCost
	// SCHEMA: mcl DependentCost!
	Mcl DependentCost
	// SCHEMA: mcli DependentCost!
	Mcli DependentCost
	// SCHEMA: mcp DependentCost!
	Mcp DependentCost
	// SCHEMA: mcpi DependentCost!
	Mcpi DependentCost
	// SCHEMA: meq DependentCost!
	Meq DependentCost
	// SCHEMA: retd DependentCost!
	Retd DependentCost
	// SCHEMA: s256 DependentCost!
	S256 DependentCost
	// SCHEMA: scwq DependentCost!
	Scwq DependentCost
	// SCHEMA: smo DependentCost!
	Smo DependentCost
	// SCHEMA: srwq DependentCost!
	Srwq DependentCost
	// SCHEMA: swwq DependentCost!
	Swwq DependentCost
	// SCHEMA: contractRoot DependentCost!
	ContractRoot DependentCost
	// SCHEMA: stateRoot DependentCost!
	StateRoot DependentCost
	// SCHEMA: vmInitialization DependentCost!
	VmInitialization DependentCost
	// SCHEMA: newStoragePerByte U64!
	NewStoragePerByte U64
}

type Genesis struct {
	// The chain configs define what consensus type to use, what settlement layer to use,
	// rules of block validity, etc.
	// SCHEMA: chainConfigHash Bytes32!
	ChainConfigHash Bytes32
	// The Binary Merkle Tree root of all genesis coins.
	// SCHEMA: coinsRoot Bytes32!
	CoinsRoot Bytes32
	// The Binary Merkle Tree root of state, balances, contracts code hash of each contract.
	// SCHEMA: contractsRoot Bytes32!
	ContractsRoot Bytes32
	// The Binary Merkle Tree root of all genesis messages.
	// SCHEMA: messagesRoot Bytes32!
	MessagesRoot Bytes32
}

type Header struct {
	// Hash of the header
	// SCHEMA: id BlockId!
	Id BlockId
	// The layer 1 height of messages and events to include since the last layer 1 block number.
	// SCHEMA: daHeight U64!
	DaHeight U64
	// Number of transactions in this block.
	// SCHEMA: transactionsCount U64!
	TransactionsCount U64
	// Number of message receipts in this block.
	// SCHEMA: messageReceiptCount U64!
	MessageReceiptCount U64
	// Merkle root of transactions.
	// SCHEMA: transactionsRoot Bytes32!
	TransactionsRoot Bytes32
	// Merkle root of message receipts in this block.
	// SCHEMA: messageReceiptRoot Bytes32!
	MessageReceiptRoot Bytes32
	// Fuel block height.
	// SCHEMA: height U32!
	Height U32
	// Merkle root of all previous block header hashes.
	// SCHEMA: prevRoot Bytes32!
	PrevRoot Bytes32
	// The block producer time.
	// SCHEMA: time Tai64Timestamp!
	Time Tai64Timestamp
	// Hash of the application header.
	// SCHEMA: applicationHash Bytes32!
	ApplicationHash Bytes32
}

type HeavyOperation struct {
	// SCHEMA: base U64!
	Base U64
	// SCHEMA: gasPerUnit U64!
	GasPerUnit U64
}

type InputCoin struct {
	// SCHEMA: utxoId UtxoId!
	UtxoId UtxoId
	// SCHEMA: owner Address!
	Owner Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
	// SCHEMA: txPointer TxPointer!
	TxPointer TxPointer
	// SCHEMA: witnessIndex Int!
	WitnessIndex Int
	// SCHEMA: maturity U32!
	Maturity U32
	// SCHEMA: predicateGasUsed U64!
	PredicateGasUsed U64
	// SCHEMA: predicate HexString!
	Predicate HexString
	// SCHEMA: predicateData HexString!
	PredicateData HexString
}

type InputContract struct {
	// SCHEMA: utxoId UtxoId!
	UtxoId UtxoId
	// SCHEMA: balanceRoot Bytes32!
	BalanceRoot Bytes32
	// SCHEMA: stateRoot Bytes32!
	StateRoot Bytes32
	// SCHEMA: txPointer TxPointer!
	TxPointer TxPointer
	// SCHEMA: contract Contract!
	Contract Contract
}

type InputMessage struct {
	// SCHEMA: sender Address!
	Sender Address
	// SCHEMA: recipient Address!
	Recipient Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: nonce Nonce!
	Nonce Nonce
	// SCHEMA: witnessIndex Int!
	WitnessIndex Int
	// SCHEMA: predicateGasUsed U64!
	PredicateGasUsed U64
	// SCHEMA: data HexString!
	Data HexString
	// SCHEMA: predicate HexString!
	Predicate HexString
	// SCHEMA: predicateData HexString!
	PredicateData HexString
}

type LightOperation struct {
	// SCHEMA: base U64!
	Base U64
	// SCHEMA: unitsPerGas U64!
	UnitsPerGas U64
}

type MerkleProof struct {
	// SCHEMA: proofSet [Bytes32!]!
	ProofSet []Bytes32
	// SCHEMA: proofIndex U64!
	ProofIndex U64
}

type Message struct {
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: sender Address!
	Sender Address
	// SCHEMA: recipient Address!
	Recipient Address
	// SCHEMA: nonce Nonce!
	Nonce Nonce
	// SCHEMA: data HexString!
	Data HexString
	// SCHEMA: daHeight U64!
	DaHeight U64
}

type MessageCoin struct {
	// SCHEMA: sender Address!
	Sender Address
	// SCHEMA: recipient Address!
	Recipient Address
	// SCHEMA: nonce Nonce!
	Nonce Nonce
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
	// SCHEMA: daHeight U64!
	DaHeight U64
}

type MessageConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [MessageEdge!]!
	Edges []MessageEdge
	// A list of nodes.
	// SCHEMA: nodes [Message!]!
	Nodes []Message
}

// An edge in a connection.
type MessageEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node Message!
	Node Message
}

type MessageProof struct {
	// SCHEMA: messageProof MerkleProof!
	MessageProof MerkleProof
	// SCHEMA: blockProof MerkleProof!
	BlockProof MerkleProof
	// SCHEMA: messageBlockHeader Header!
	MessageBlockHeader Header
	// SCHEMA: commitBlockHeader Header!
	CommitBlockHeader Header
	// SCHEMA: sender Address!
	Sender Address
	// SCHEMA: recipient Address!
	Recipient Address
	// SCHEMA: nonce Nonce!
	Nonce Nonce
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: data HexString!
	Data HexString
}

type MessageStatus struct {
	// SCHEMA: state MessageState!
	State MessageState
}

type Mutation struct {
	// SCHEMA: startSession ID!
	StartSession ID
	// SCHEMA: endSession Boolean!
	EndSession Boolean
	// SCHEMA: reset Boolean!
	Reset Boolean
	// SCHEMA: execute Boolean!
	Execute Boolean
	// SCHEMA: setSingleStepping Boolean!
	SetSingleStepping Boolean
	// SCHEMA: setBreakpoint Boolean!
	SetBreakpoint Boolean
	// SCHEMA: startTx RunResult!
	StartTx RunResult
	// SCHEMA: continueTx RunResult!
	ContinueTx RunResult
	// Execute a dry-run of the transaction using a fork of current state, no changes are committed.
	// SCHEMA: dryRun [Receipt!]!
	DryRun []Receipt
	// Submits transaction to the `TxPool`.
	//
	// Returns submitted transaction if the transaction is included in the `TxPool` without problems.
	// SCHEMA: submit Transaction!
	Submit Transaction
	// Sequentially produces `blocks_to_produce` blocks. The first block starts with
	// `start_timestamp`. If the block production in the [`crate::service::Config`] is
	// `Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between
	// them. The `start_timestamp` is the timestamp in seconds.
	// SCHEMA: produceBlocks U32!
	ProduceBlocks U32
}

type NodeInfo struct {
	// SCHEMA: utxoValidation Boolean!
	UtxoValidation Boolean
	// SCHEMA: vmBacktrace Boolean!
	VmBacktrace Boolean
	// SCHEMA: minGasPrice U64!
	MinGasPrice U64
	// SCHEMA: maxTx U64!
	MaxTx U64
	// SCHEMA: maxDepth U64!
	MaxDepth U64
	// SCHEMA: nodeVersion String!
	NodeVersion String
	// SCHEMA: peers [PeerInfo!]!
	Peers []PeerInfo
}

// A separate `Breakpoint` type to be used as an output, as a single
// type cannot act as both input and output type in async-graphql
type OutputBreakpoint struct {
	// SCHEMA: contract ContractId!
	Contract ContractId
	// SCHEMA: pc U64!
	Pc U64
}

// Information about pagination in a connection
type PageInfo struct {
	// When paginating backwards, are there more items?
	// SCHEMA: hasPreviousPage Boolean!
	HasPreviousPage Boolean
	// When paginating forwards, are there more items?
	// SCHEMA: hasNextPage Boolean!
	HasNextPage Boolean
	// When paginating backwards, the cursor to continue.
	// SCHEMA: startCursor String
	StartCursor *String
	// When paginating forwards, the cursor to continue.
	// SCHEMA: endCursor String
	EndCursor *String
}

type PeerInfo struct {
	// The libp2p peer id
	// SCHEMA: id String!
	Id String
	// The advertised multi-addrs that can be used to connect to this peer
	// SCHEMA: addresses [String!]!
	Addresses []String
	// The self-reported version of the client the peer is using
	// SCHEMA: clientVersion String
	ClientVersion *String
	// The last reported height of the peer
	// SCHEMA: blockHeight U32
	BlockHeight *U32
	// The last heartbeat from this peer in unix epoch time ms
	// SCHEMA: lastHeartbeatMs U64!
	LastHeartbeatMs U64
	// The internal fuel p2p reputation of this peer
	// SCHEMA: appScore Float!
	AppScore Float
}

type PoAConsensus struct {
	// Gets the signature of the block produced by `PoA` consensus.
	// SCHEMA: signature Signature!
	Signature Signature
}

type Policies struct {
	// SCHEMA: gasPrice U64
	GasPrice *U64
	// SCHEMA: witnessLimit U64
	WitnessLimit *U64
	// SCHEMA: maturity U32
	Maturity *U32
	// SCHEMA: maxFee U64
	MaxFee *U64
}

type PredicateParameters struct {
	// SCHEMA: maxPredicateLength U64!
	MaxPredicateLength U64
	// SCHEMA: maxPredicateDataLength U64!
	MaxPredicateDataLength U64
	// SCHEMA: maxGasPerPredicate U64!
	MaxGasPerPredicate U64
	// SCHEMA: maxMessageDataLength U64!
	MaxMessageDataLength U64
}

type ProgramState struct {
	// SCHEMA: returnType ReturnType!
	ReturnType ReturnType
	// SCHEMA: data HexString!
	Data HexString
}

type Query struct {
	// SCHEMA: register U64!
	Register U64
	// SCHEMA: memory String!
	Memory String
	// SCHEMA: balance Balance!
	Balance Balance
	// SCHEMA: balances BalanceConnection!
	Balances BalanceConnection
	// SCHEMA: block Block
	Block *Block
	// SCHEMA: blocks BlockConnection!
	Blocks BlockConnection
	// SCHEMA: chain ChainInfo!
	Chain ChainInfo
	// SCHEMA: transaction Transaction
	Transaction *Transaction
	// SCHEMA: transactions TransactionConnection!
	Transactions TransactionConnection
	// SCHEMA: transactionsByOwner TransactionConnection!
	TransactionsByOwner TransactionConnection
	// Estimate the predicate gas for the provided transaction
	// SCHEMA: estimatePredicates Transaction!
	EstimatePredicates Transaction
	// Returns true when the GraphQL API is serving requests.
	// SCHEMA: health Boolean!
	Health Boolean
	// Gets the coin by `utxo_id`.
	// SCHEMA: coin Coin
	Coin *Coin
	// Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page.
	// SCHEMA: coins CoinConnection!
	Coins CoinConnection
	// For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by
	// `owner` that add up at least the query amount. The returned coins can be spent.
	// The number of coins is optimized to prevent dust accumulation.
	//
	// The query supports excluding and maximum the number of coins.
	//
	// Returns:
	// The list of spendable coins per asset from the query. The length of the result is
	// the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
	// is the same.
	// SCHEMA: coinsToSpend [[CoinType!]!]!
	CoinsToSpend [][]CoinType
	// SCHEMA: contract Contract
	Contract *Contract
	// SCHEMA: contractBalance ContractBalance!
	ContractBalance ContractBalance
	// SCHEMA: contractBalances ContractBalanceConnection!
	ContractBalances ContractBalanceConnection
	// SCHEMA: nodeInfo NodeInfo!
	NodeInfo NodeInfo
	// SCHEMA: messages MessageConnection!
	Messages MessageConnection
	// SCHEMA: messageProof MessageProof
	MessageProof *MessageProof
	// SCHEMA: messageStatus MessageStatus!
	MessageStatus MessageStatus
}

type Receipt struct {
	// SCHEMA: contract Contract
	Contract *Contract
	// SCHEMA: pc U64
	Pc *U64
	// SCHEMA: is U64
	Is *U64
	// SCHEMA: to Contract
	To *Contract
	// SCHEMA: toAddress Address
	ToAddress *Address
	// SCHEMA: amount U64
	Amount *U64
	// SCHEMA: assetId AssetId
	AssetId *AssetId
	// SCHEMA: gas U64
	Gas *U64
	// SCHEMA: param1 U64
	Param1 *U64
	// SCHEMA: param2 U64
	Param2 *U64
	// SCHEMA: val U64
	Val *U64
	// SCHEMA: ptr U64
	Ptr *U64
	// SCHEMA: digest Bytes32
	Digest *Bytes32
	// SCHEMA: reason U64
	Reason *U64
	// SCHEMA: ra U64
	Ra *U64
	// SCHEMA: rb U64
	Rb *U64
	// SCHEMA: rc U64
	Rc *U64
	// SCHEMA: rd U64
	Rd *U64
	// SCHEMA: len U64
	Len *U64
	// SCHEMA: receiptType ReceiptType!
	ReceiptType ReceiptType
	// SCHEMA: result U64
	Result *U64
	// SCHEMA: gasUsed U64
	GasUsed *U64
	// SCHEMA: data HexString
	Data *HexString
	// SCHEMA: sender Address
	Sender *Address
	// SCHEMA: recipient Address
	Recipient *Address
	// SCHEMA: nonce Nonce
	Nonce *Nonce
	// SCHEMA: contractId ContractId
	ContractId *ContractId
	// SCHEMA: subId Bytes32
	SubId *Bytes32
}

type RunResult struct {
	// SCHEMA: state RunState!
	State RunState
	// SCHEMA: breakpoint OutputBreakpoint
	Breakpoint *OutputBreakpoint
	// SCHEMA: jsonReceipts [String!]!
	JsonReceipts []String
}

type ScriptParameters struct {
	// SCHEMA: maxScriptLength U64!
	MaxScriptLength U64
	// SCHEMA: maxScriptDataLength U64!
	MaxScriptDataLength U64
}

type SqueezedOutStatus struct {
	// SCHEMA: reason String!
	Reason String
}

type SubmittedStatus struct {
	// SCHEMA: time Tai64Timestamp!
	Time Tai64Timestamp
}

type Subscription struct {
	// Returns a stream of status updates for the given transaction id.
	// If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]
	// or [`TransactionStatus::Failed`] the stream will return that and end immediately.
	// If the current status is [`TransactionStatus::Submitted`] this will be returned
	// and the stream will wait for a future update.
	//
	// This stream will wait forever so it's advised to use within a timeout.
	//
	// It is possible for the stream to miss an update if it is polled slower
	// then the updates arrive. In such a case the stream will close without
	// a status. If this occurs the stream can simply be restarted to return
	// the latest status.
	// SCHEMA: statusChange TransactionStatus!
	StatusChange TransactionStatus
	// Submits transaction to the `TxPool` and await either confirmation or failure.
	// SCHEMA: submitAndAwait TransactionStatus!
	SubmitAndAwait TransactionStatus
}

type SuccessStatus struct {
	// SCHEMA: transactionId TransactionId!
	TransactionId TransactionId
	// SCHEMA: block Block!
	Block Block
	// SCHEMA: time Tai64Timestamp!
	Time Tai64Timestamp
	// SCHEMA: programState ProgramState
	ProgramState *ProgramState
	// SCHEMA: receipts [Receipt!]!
	Receipts []Receipt
}

type Transaction struct {
	// SCHEMA: id TransactionId!
	Id TransactionId
	// SCHEMA: inputAssetIds [AssetId!]
	InputAssetIds []AssetId
	// SCHEMA: inputContracts [Contract!]
	InputContracts []Contract
	// SCHEMA: inputContract InputContract
	InputContract *InputContract
	// SCHEMA: policies Policies
	Policies *Policies
	// SCHEMA: gasPrice U64
	GasPrice *U64
	// SCHEMA: scriptGasLimit U64
	ScriptGasLimit *U64
	// SCHEMA: maturity U32
	Maturity *U32
	// SCHEMA: mintAmount U64
	MintAmount *U64
	// SCHEMA: mintAssetId AssetId
	MintAssetId *AssetId
	// SCHEMA: txPointer TxPointer
	TxPointer *TxPointer
	// SCHEMA: isScript Boolean!
	IsScript Boolean
	// SCHEMA: isCreate Boolean!
	IsCreate Boolean
	// SCHEMA: isMint Boolean!
	IsMint Boolean
	// SCHEMA: inputs [Input!]
	Inputs []Input
	// SCHEMA: outputs [Output!]!
	Outputs []Output
	// SCHEMA: outputContract ContractOutput
	OutputContract *ContractOutput
	// SCHEMA: witnesses [HexString!]
	Witnesses []HexString
	// SCHEMA: receiptsRoot Bytes32
	ReceiptsRoot *Bytes32
	// SCHEMA: status TransactionStatus
	Status *TransactionStatus
	// SCHEMA: receipts [Receipt!]
	Receipts []Receipt
	// SCHEMA: script HexString
	Script *HexString
	// SCHEMA: scriptData HexString
	ScriptData *HexString
	// SCHEMA: bytecodeWitnessIndex Int
	BytecodeWitnessIndex *Int
	// SCHEMA: bytecodeLength U64
	BytecodeLength *U64
	// SCHEMA: salt Salt
	Salt *Salt
	// SCHEMA: storageSlots [HexString!]
	StorageSlots []HexString
	// Return the transaction bytes using canonical encoding
	// SCHEMA: rawPayload HexString!
	RawPayload HexString
}

type TransactionConnection struct {
	// Information to aid in pagination.
	// SCHEMA: pageInfo PageInfo!
	PageInfo PageInfo
	// A list of edges.
	// SCHEMA: edges [TransactionEdge!]!
	Edges []TransactionEdge
	// A list of nodes.
	// SCHEMA: nodes [Transaction!]!
	Nodes []Transaction
}

// An edge in a connection.
type TransactionEdge struct {
	// A cursor for use in pagination
	// SCHEMA: cursor String!
	Cursor String
	// The item at the end of the edge
	// SCHEMA: node Transaction!
	Node Transaction
}

type TxParameters struct {
	// SCHEMA: maxInputs U8!
	MaxInputs U8
	// SCHEMA: maxOutputs U8!
	MaxOutputs U8
	// SCHEMA: maxWitnesses U32!
	MaxWitnesses U32
	// SCHEMA: maxGasPerTx U64!
	MaxGasPerTx U64
	// SCHEMA: maxSize U64!
	MaxSize U64
}

type VariableOutput struct {
	// SCHEMA: to Address!
	To Address
	// SCHEMA: amount U64!
	Amount U64
	// SCHEMA: assetId AssetId!
	AssetId AssetId
}

// ====================
// union types
// --------------------

// The schema analog of the [`coins::CoinType`].
type CoinType struct {
	*Coin
	*MessageCoin
}

type Consensus struct {
	*Genesis
	*PoAConsensus
}

type DependentCost struct {
	*LightOperation
	*HeavyOperation
}

type Input struct {
	*InputCoin
	*InputContract
	*InputMessage
}

type Output struct {
	*CoinOutput
	*ContractOutput
	*ChangeOutput
	*VariableOutput
	*ContractCreated
}

type TransactionStatus struct {
	*SubmittedStatus
	*SuccessStatus
	*SqueezedOutStatus
	*FailureStatus
}
