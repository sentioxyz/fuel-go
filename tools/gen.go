package main

import (
	"flag"
	"fmt"
	"github.com/graph-gophers/graphql-go"
	"github.com/graph-gophers/graphql-go/types"
	"gopkg.in/yaml.v3"
	"io"
	"log"
	"os"
	"sort"
	"strings"
)

type Config struct {
	Package      string            `yaml:"package"`
	Import       []string          `yaml:"import"`
	JSONPackage  string            `yaml:"json-package"`
	ScalarMapper map[string]string `yaml:"scalarMapper"`
}

type Output struct {
	io.Writer
}

func (o *Output) Out(format string, args ...any) {
	_, err := fmt.Fprintf(o.Writer, format, args...)
	if err != nil {
		log.Fatalf("write failed: %v", err)
	}
}

func (o *Output) OutLines(cnt, prefix string) {
	cnt = strings.TrimSpace(cnt)
	if cnt == "" {
		return
	}
	for _, line := range strings.Split(cnt, "\n") {
		o.Out("%s%s\n", prefix, line)
	}
}

func isBuiltinTypes(goTypeName string) bool {
	switch goTypeName {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
	case "float32", "float64":
	case "string":
	case "bool":
	default:
		return false
	}
	return true
}

func convertToGoType(typ types.Type, wrappedNonNull bool) string {
	switch t := typ.(type) {
	case *types.NonNull:
		return convertToGoType(t.OfType, true)
	case *types.List:
		return "[]" + convertToGoType(t.OfType, false)
	default:
		if wrappedNonNull {
			return t.String()
		}
		return "*" + t.String()
	}
}

func Gen(schema *types.Schema, config Config, out io.Writer) {
	w := Output{Writer: out}
	w.Out("// Auto generated by tools, do not edit\n\n")

	// sort schema.Types
	schemaTypes := make([]types.NamedType, 0, len(schema.Types))
	for _, typ := range schema.Types {
		schemaTypes = append(schemaTypes, typ)
	}
	sort.Slice(schemaTypes, func(i, j int) bool {
		return schemaTypes[i].TypeName() < schemaTypes[j].TypeName()
	})

	// package
	w.Out("package %s\n\n", config.Package)

	// import
	w.Out("import (\n")
	w.Out("\t%q\n", "fmt")
	w.Out("\t%q\n", config.JSONPackage)
	for _, imp := range config.Import {
		w.Out("\t%q\n", imp)
	}
	w.Out(")\n\n")

	// scalar types
	w.Out("// ====================\n// scalar types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		scalarType, is := typ.(*types.ScalarTypeDefinition)
		if !is {
			continue
		}
		scalarGoType, has := config.ScalarMapper[scalarType.TypeName()]
		if !has {
			log.Fatalf("miss mapping for scalar type %q", scalarType.TypeName())
		}

		if isBuiltinTypes(scalarGoType) {
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
		} else {
			w.Out("type %s struct { %s }\n", scalarType.TypeName(), scalarGoType)
		}
	}
	w.Out("\n")

	// enum types
	w.Out("// ====================\n// enum types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		enumType, is := typ.(*types.EnumTypeDefinition)
		if !is || strings.HasPrefix(enumType.TypeName(), "_") {
			continue
		}
		w.OutLines(enumType.Desc, "// ")
		w.Out("type %s string\n\n", enumType.TypeName())
		w.Out("var %sValues = []string{\n", enumType.TypeName())
		for _, val := range enumType.EnumValuesDefinition {
			w.Out("  %q,\n", val.EnumValue)
		}
		w.Out(`}

func (e *%s) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range %sValues {
		if v == val {
			*e = %s(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %%q for enum type %s", val)
}

`, enumType.TypeName(), enumType.TypeName(), enumType.TypeName(), enumType.TypeName())
	}

	// object types
	w.Out("// ====================\n// object types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		objectType, is := typ.(*types.ObjectTypeDefinition)
		if !is || strings.HasPrefix(objectType.TypeName(), "_") {
			continue
		}
		w.OutLines(objectType.Desc, "// ")
		w.Out("type %s struct {\n", objectType.TypeName())
		for _, field := range objectType.Fields {
			goFieldName := strings.ToUpper(field.Name[:1]) + field.Name[1:]
			w.OutLines(field.Desc, "\t// ")
			w.Out("\t// SCHEMA: %s %s\n", field.Name, field.Type.String())
			w.Out("\t%s %s\n", goFieldName, convertToGoType(field.Type, false))
		}
		w.Out("}\n\n")
	}

	// union types
	w.Out("// ====================\n// union types\n// --------------------\n\n")
	for _, unionType := range schema.Unions {
		w.OutLines(unionType.Desc, "// ")
		w.Out("type %s struct {\n", unionType.TypeName())
		for _, mem := range unionType.UnionMemberTypes {
			w.Out("\t*%s\n", mem.TypeName())
		}
		w.Out("}\n\n")
	}
}

func main() {
	schemaFile := flag.String("schema-file", "./schema.graphql", "path of the schema file")
	configFile := flag.String("config-file", "./config.yaml", "path of the config yaml file")
	outputFile := flag.String("output-file", "../types.go", "path of the output file")

	// load schema
	schemaCnt, err := os.ReadFile(*schemaFile)
	if err != nil {
		log.Fatalf("read schema file failed: %v", err)
	}
	schema, err := graphql.ParseSchema(string(schemaCnt), nil)
	if err != nil {
		log.Fatalf("parse schema failed: %v", err)
	}

	// load config
	configCnt, err := os.ReadFile(*configFile)
	if err != nil {
		log.Fatalf("read config file failed: %v", err)
	}
	var conf Config
	if err = yaml.Unmarshal(configCnt, &conf); err != nil {
		log.Fatalf("parse config failed: %v", err)
	}

	// open output file
	out, err := os.Create(*outputFile)
	if err != nil {
		log.Fatalf("open output file failed: %v", err)
	}
	defer out.Close()

	// gen
	Gen(schema.ASTSchema(), conf, out)
}
