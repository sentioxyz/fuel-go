package main

import (
	"flag"
	"fmt"
	"github.com/graph-gophers/graphql-go"
	"github.com/graph-gophers/graphql-go/types"
	"gopkg.in/yaml.v3"
	"io"
	"log"
	"os"
	"sort"
	"strings"
)

type Config struct {
	Package      string            `yaml:"package"`
	Import       []string          `yaml:"import"`
	JSONPackage  string            `yaml:"json-package"`
	ScalarMapper map[string]string `yaml:"scalarMapper"`
}

type Output struct {
	io.Writer
}

func (o *Output) Out(format string, args ...any) {
	_, err := fmt.Fprintf(o.Writer, format, args...)
	if err != nil {
		log.Fatalf("write failed: %v", err)
	}
}

func (o *Output) OutLines(cnt, prefix string) {
	cnt = strings.TrimSpace(cnt)
	if cnt == "" {
		return
	}
	for _, line := range strings.Split(cnt, "\n") {
		o.Out("%s%s\n", prefix, line)
	}
}

func isBuiltinTypes(goTypeName string) bool {
	switch goTypeName {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
	case "float32", "float64":
	case "string":
	case "bool":
	default:
		return false
	}
	return true
}

func convertToGoType(typ types.Type, wrappedNonNull bool) string {
	switch t := typ.(type) {
	case *types.NonNull:
		return convertToGoType(t.OfType, true)
	case *types.List:
		return "[]" + convertToGoType(t.OfType, false)
	default:
		if wrappedNonNull {
			return t.String()
		}
		return "*" + t.String()
	}
}

func Gen(schema *types.Schema, config Config, out io.Writer) {
	w := Output{Writer: out}
	w.Out("// Auto generated by tools, do not edit\n\n")

	// sort schema.Types
	schemaTypes := make([]types.NamedType, 0, len(schema.Types))
	for _, typ := range schema.Types {
		schemaTypes = append(schemaTypes, typ)
	}
	sort.Slice(schemaTypes, func(i, j int) bool {
		return schemaTypes[i].TypeName() < schemaTypes[j].TypeName()
	})

	// package
	w.Out("package %s\n\n", config.Package)

	// import
	w.Out("import (\n")
	for _, imp := range append(config.Import, config.JSONPackage, "fmt", "reflect", "strconv") {
		w.Out("\t%q\n", imp)
	}
	w.Out(")\n\n")

	// scalar types
	w.Out("// ====================\n// scalar types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		scalarType, is := typ.(*types.ScalarTypeDefinition)
		if !is {
			continue
		}
		scalarGoType, has := config.ScalarMapper[scalarType.TypeName()]
		if !has {
			log.Fatalf("miss mapping for scalar type %q", scalarType.TypeName())
		}

		switch scalarGoType {
		case "uint8", "uint16", "uint32", "uint64":
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
			w.Out(`
func (s *%s) UnmarshalJSON(raw []byte) error {
	if i, err := UnmarshalJSONUInt(raw); err != nil {
		return err
	} else {
		*s = %s(i)
		return nil
	}
}

`, scalarType.TypeName(), scalarType.TypeName())
		case "int8", "int16", "int32", "int64":
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
			w.Out(`
func (s *%s) UnmarshalJSON(raw []byte) error {
	if i, err := UnmarshalJSONInt(raw); err != nil {
		return err
	} else {
		*s = %s(i)
		return nil
	}
}

`, scalarType.TypeName(), scalarType.TypeName())
		case "float32", "float64":
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
			w.Out(`
func (s *%s) UnmarshalJSON(raw []byte) error {
	if f, err := UnmarshalJSONFloat(raw); err != nil {
		return err
	} else {
		*s = %s(f)
		return nil
	}
}

`, scalarType.TypeName(), scalarType.TypeName())
		case "string":
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
		case "bool":
			w.Out("type %s %s\n", scalarType.TypeName(), scalarGoType)
		default:
			w.Out("type %s struct { %s }\n", scalarType.TypeName(), scalarGoType)
		}
	}
	w.Out(`

func UnmarshalJSONUInt(raw []byte) (uint64, error) {
	if len(raw) >= 2 && raw[0] == '"' && raw[len(raw)-1] == '"' {
		raw = raw[1:len(raw)-1]
	}
	return strconv.ParseUint(string(raw), 10, 64)
}

func UnmarshalJSONInt(raw []byte) (int64, error) {
	if len(raw) >= 2 && raw[0] == '"' && raw[len(raw)-1] == '"' {
		raw = raw[1:len(raw)-1]
	}
	return strconv.ParseInt(string(raw), 10, 64)
}

func UnmarshalJSONFloat(raw []byte) (float64, error) {
	if len(raw) >= 2 && raw[0] == '"' && raw[len(raw)-1] == '"' {
		raw = raw[1:len(raw)-1]
	}
	return strconv.ParseFloat(string(raw), 64)
}

`)

	// enum types
	w.Out("// ====================\n// enum types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		enumType, is := typ.(*types.EnumTypeDefinition)
		if !is || strings.HasPrefix(enumType.TypeName(), "_") {
			continue
		}
		w.OutLines(enumType.Desc, "// ")
		w.Out("type %s string\n\n", enumType.TypeName())
		w.Out("var %sValues = []string{\n", enumType.TypeName())
		for _, val := range enumType.EnumValuesDefinition {
			w.Out("  %q,\n", val.EnumValue)
		}
		w.Out(`}

func (e *%s) UnmarshalJSON(raw []byte) error {
	var val string
	if err := json.Unmarshal(raw, &val); err != nil {
		return err
	}
	for _, v := range %sValues {
		if v == val {
			*e = %s(val)
			return nil
		}
	}
	return fmt.Errorf("invalid value %%q for enum type %s", val)
}

`, enumType.TypeName(), enumType.TypeName(), enumType.TypeName(), enumType.TypeName())
	}

	// object types
	w.Out("// ====================\n// object types\n// --------------------\n\n")
	for _, typ := range schemaTypes {
		objectType, is := typ.(*types.ObjectTypeDefinition)
		if !is || strings.HasPrefix(objectType.TypeName(), "_") {
			continue
		}
		w.OutLines(objectType.Desc, "// ")
		w.Out("type %s struct {\n", objectType.TypeName())
		for _, field := range objectType.Fields {
			goFieldName := strings.ToUpper(field.Name[:1]) + field.Name[1:]
			w.OutLines(field.Desc, "\t// ")
			w.Out("\t// SCHEMA: %s %s\n", field.Name, field.Type.String())
			w.Out("\t%s %s `json:\"%s\"`\n", goFieldName, convertToGoType(field.Type, false), field.Name)
		}
		w.Out("}\n\n")
	}

	// union types
	w.Out("// ====================\n// union types\n// --------------------\n\n")
	for _, unionType := range schema.Unions {
		w.OutLines(unionType.Desc, "// ")
		w.Out("type %s struct {\n", unionType.TypeName())
		for _, mem := range unionType.UnionMemberTypes {
			w.Out("\t*%s\n", mem.TypeName())
		}
		w.Out("}\n\n")
		w.Out(`
func (u *%s) UnmarshalJSON(raw []byte) error {
	return UnmarshalJSONUnion(raw, u)
}

`, unionType.TypeName())
	}
	w.Out(`

func UnmarshalJSONUnion(raw []byte, unionObj any) error {
	var union struct {
		TypeName string ` + "`" + `json:"__typename"` + "`" + `
	}
	if err := json.Unmarshal(raw, &union); err != nil {
		return err
	}
	pv := reflect.ValueOf(unionObj)
	if pv.Kind() != reflect.Pointer || pv.IsNil() {
		return &json.InvalidUnmarshalError{Type: reflect.TypeOf(unionObj)}
	}
	rv := pv.Elem()
	rt := rv.Type()
	for i := 0; i < rt.NumField(); i++ {
		if rt.Field(i).Name == union.TypeName {
			if rt.Field(i).Type.Kind() != reflect.Pointer {
				return fmt.Errorf("member %%s of union type %%T should be an pointer", union.TypeName, unionObj)
			}
			fv := reflect.New(rt.Field(i).Type.Elem())
			if err := json.Unmarshal(raw, fv.Interface()); err != nil {
				return err
			}
			rv.Field(i).Set(fv)
			return nil
		}
	}
	return fmt.Errorf("union type %%T do not have member %%s", unionObj, union.TypeName)
}

`)
}

func main() {
	schemaFile := flag.String("schema-file", "./schema.graphql", "path of the schema file")
	configFile := flag.String("config-file", "./config.yaml", "path of the config yaml file")
	outputFile := flag.String("output-file", "../types.go", "path of the output file")

	flag.Parse()

	// load schema
	schemaCnt, err := os.ReadFile(*schemaFile)
	if err != nil {
		log.Fatalf("read schema file failed: %v", err)
	}
	schema, err := graphql.ParseSchema(string(schemaCnt), nil)
	if err != nil {
		log.Fatalf("parse schema failed: %v", err)
	}

	// load config
	configCnt, err := os.ReadFile(*configFile)
	if err != nil {
		log.Fatalf("read config file failed: %v", err)
	}
	var conf Config
	if err = yaml.Unmarshal(configCnt, &conf); err != nil {
		log.Fatalf("parse config failed: %v", err)
	}

	// open output file
	out, err := os.Create(*outputFile)
	if err != nil {
		log.Fatalf("open output file failed: %v", err)
	}
	defer out.Close()

	// gen
	Gen(schema.ASTSchema(), conf, out)
}
